// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`loadIntermApplicationPayment should call sequelize.query with correct parameters if one record is found 1`] = `
[MockFunction] {
  "calls": [
    [
      "
    WITH newdata AS (
      SELECT
        CL."applicationId",
        APN."invoiceNumber",
        substring(APN."invoiceNumber", position('A' in APN."invoiceNumber") + 2, length(APN."invoiceNumber") - (position('A' in APN."invoiceNumber") + 1))::integer AS "invoiceId",
        "idClcHeader",
        APN."changeType"
      FROM public."etlStageAppsPaymentNotification" APN
      INNER JOIN public."etlStageCssContractApplications" CA 
        ON APN."applicationId" = CA."applicationId"
      INNER JOIN public."etlStageCssContractApplications" CL 
        ON CA."contractId" = CL."contractId"
      WHERE CA."dataSourceSCode" = 'CAPCLM'
        AND CL."dataSourceSCode" = '000001'
        AND APN."notificationFlag" = 'P'
        AND APN."etlId" BETWEEN 1 AND 2
        
    ),
    updatedrows AS (
      UPDATE public."etlIntermApplicationPayment" interm
      SET
        "invoiceNumber" = newdata."invoiceNumber",
        "invoiceId" = newdata."invoiceId",
        "etlInsertedDt" = NOW()
      FROM newdata
      WHERE newdata."changeType" = 'UPDATE'
        AND interm."applicationId" = newdata."applicationId"
        AND interm."idClcHeader" = newdata."idClcHeader"
      RETURNING interm."applicationId", interm."idClcHeader"
    )
    INSERT INTO public."etlIntermApplicationPayment" (
      "applicationId",
      "invoiceNumber",
      "invoiceId",
      "idClcHeader"
    )
    SELECT
      "applicationId",
      "invoiceNumber",
      "invoiceId",
      "idClcHeader"
    FROM newdata
      WHERE "changeType" = 'INSERT'
        OR ("changeType" = 'UPDATE' AND ("applicationId", "idClcHeader") NOT IN (SELECT "applicationId", "idClcHeader" FROM updatedrows));
  ",
      {
        "raw": true,
        "replacements": {},
        "transaction": undefined,
      },
    ],
    [
      "
    WITH newdata AS (
      SELECT
        CL."applicationId",
        APN."invoiceNumber",
        substring(APN."invoiceNumber", position('A' in APN."invoiceNumber") + 2, length(APN."invoiceNumber") - (position('A' in APN."invoiceNumber") + 1))::integer AS "invoiceId",
        "idClcHeader",
        APN."changeType"
      FROM public."etlStageAppsPaymentNotification" APN
      INNER JOIN public."etlStageCssContractApplications" CA 
        ON APN."applicationId" = CA."applicationId"
      INNER JOIN public."etlStageCssContractApplications" CL 
        ON CA."contractId" = CL."contractId"
      WHERE CA."dataSourceSCode" = 'CAPCLM'
        AND CL."dataSourceSCode" = '000001'
        AND APN."notificationFlag" = 'P'
        AND APN."etlId" BETWEEN 1 AND 2
         AND APN."etlId" NOT BETWEEN 1 AND 2
    ),
    updatedrows AS (
      UPDATE public."etlIntermApplicationPayment" interm
      SET
        "invoiceNumber" = newdata."invoiceNumber",
        "invoiceId" = newdata."invoiceId",
        "etlInsertedDt" = NOW()
      FROM newdata
      WHERE newdata."changeType" = 'UPDATE'
        AND interm."applicationId" = newdata."applicationId"
        AND interm."idClcHeader" = newdata."idClcHeader"
      RETURNING interm."applicationId", interm."idClcHeader"
    )
    INSERT INTO public."etlIntermApplicationPayment" (
      "applicationId",
      "invoiceNumber",
      "invoiceId",
      "idClcHeader"
    )
    SELECT
      "applicationId",
      "invoiceNumber",
      "invoiceId",
      "idClcHeader"
    FROM newdata
      WHERE "changeType" = 'INSERT'
        OR ("changeType" = 'UPDATE' AND ("applicationId", "idClcHeader") NOT IN (SELECT "applicationId", "idClcHeader" FROM updatedrows));
  ",
      {
        "raw": true,
        "replacements": {},
        "transaction": undefined,
      },
    ],
  ],
  "results": [
    {
      "type": "return",
      "value": undefined,
    },
    {
      "type": "return",
      "value": undefined,
    },
  ],
}
`;
